searchState.loadedDescShard("core", 4, "Reversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReverse elements in 64-bit doublewords Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nReversing vector elements (swap endianness) Arm’s …\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nRounding halving add Arm’s documentation\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nFloating-point round to integral, to nearest with ties to …\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nSigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nUnsigned rounding shift left Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nRounding shift right narrow Arm’s documentation\nRounding shift right narrow Arm’s documentation\nRounding shift right narrow Arm’s documentation\nRounding shift right narrow Arm’s documentation\nRounding shift right narrow Arm’s documentation\nRounding shift right narrow Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nSigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nUnsigned rounding shift right Arm’s documentation\nReciprocal square-root estimate. Arm’s documentation\nReciprocal square-root estimate. Arm’s documentation\nUnsigned reciprocal square root estimate Arm’s …\nReciprocal square-root estimate. Arm’s documentation\nReciprocal square-root estimate. Arm’s documentation\nUnsigned reciprocal square root estimate Arm’s …\nFloating-point reciprocal square root step Arm’s …\nFloating-point reciprocal square root step Arm’s …\nFloating-point reciprocal square root step Arm’s …\nFloating-point reciprocal square root step Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nSigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nUnsigned rounding shift right and accumulate Arm’s …\nRounding subtract returning high narrow Arm’s …\nRounding subtract returning high narrow Arm’s …\nRounding subtract returning high narrow Arm’s …\nRounding subtract returning high narrow Arm’s …\nRounding subtract returning high narrow Arm’s …\nRounding subtract returning high narrow Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nInsert vector element from another vector element Arm’s …\nSHA1 hash update accelerator, choose. Arm’s documentation\nSHA1 fixed rotate. Arm’s documentation\nSHA1 hash update accelerator, majority Arm’s …\nSHA1 hash update accelerator, parity Arm’s documentation\nSHA1 schedule update accelerator, first part. Arm’s …\nSHA1 schedule update accelerator, second part. Arm’s …\nSHA1 schedule update accelerator, upper part. Arm’s …\nSHA1 schedule update accelerator, first part. Arm’s …\nSHA256 schedule update accelerator, first part. Arm’s …\nSHA256 schedule update accelerator, second part. Arm’s …\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nSigned shift left long Arm’s documentation\nSigned shift left long Arm’s documentation\nSigned shift left long Arm’s documentation\nSigned shift left long Arm’s documentation\nSigned shift left long Arm’s documentation\nSigned shift left long Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nShift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nSigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nUnsigned Shift left Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right narrow Arm’s documentation\nShift right narrow Arm’s documentation\nShift right narrow Arm’s documentation\nShift right narrow Arm’s documentation\nShift right narrow Arm’s documentation\nShift right narrow Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nShift right Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nSigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nUnsigned shift right and accumulate Arm’s documentation\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures from one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple single-element structures to one, two, …\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 2-element structures from two registers Arm…\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 3-element structures from three registers …\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore multiple 4-element structures from four registers Arm…\nStore SIMD&amp;FP register (immediate offset) Arm’s …\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSubtract returning high narrow Arm’s documentation\nSigned Subtract Long Arm’s documentation\nSigned Subtract Long Arm’s documentation\nSigned Subtract Long Arm’s documentation\nUnsigned Subtract Long Arm’s documentation\nUnsigned Subtract Long Arm’s documentation\nUnsigned Subtract Long Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSubtract Arm’s documentation\nSigned Subtract Wide Arm’s documentation\nSigned Subtract Wide Arm’s documentation\nSigned Subtract Wide Arm’s documentation\nUnsigned Subtract Wide Arm’s documentation\nUnsigned Subtract Wide Arm’s documentation\nUnsigned Subtract Wide Arm’s documentation\nDot product index form with signed and unsigned integers …\nDot product index form with signed and unsigned integers …\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nTranspose elements Arm’s documentation\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nSigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nUnsigned compare bitwise Test bits nonzero Arm’s …\nDot product index form with unsigned and signed integers …\nDot product vector form with unsigned and signed integers …\nDot product index form with unsigned and signed integers …\nDot product vector form with unsigned and signed integers …\nUnsigned and signed 8-bit integer matrix …\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nUnzip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nZip vectors Arm’s documentation\nGenerates the breakpoint instruction\nGenerates the cache operation instruction\nReads the CPU configuration register\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nReads the CSR\nWrites the CSR\nExchanges the CSR\nGenerates the memory barrier instruction\nCalculate the approximate double-precision result of 1.0 …\nCalculate the approximate single-precision result of 1.0 …\nCalculate the approximate double-precision result of …\nCalculate the approximate single-precision result of …\nGenerates the instruction-fetch barrier instruction\nReads the 8-bit IO-CSR\nReads the 16-bit IO-CSR\nReads the 32-bit IO-CSR\nWrites the 8-bit IO-CSR\nWrites the 16-bit IO-CSR\nWrites the 32-bit IO-CSR\nMoves data from a FCSR to the GPR\nMoves data from a GPR to the FCSR\nReads the upper 32-bit stable counter value and the …\nReads the lower 32-bit stable counter value and the …\nGenerates the syscall instruction\nGenerates the greater-than asseration instruction\nGenerates the less-than-or-equal asseration instruction\nGenerates the breakpoint instruction\nGenerates the cache operation instruction\nReads the CPU configuration register\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the IEEE 802.3 polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nCalculate the CRC value using the Castagnoli polynomial …\nReads the CSR\nWrites the CSR\nExchanges the CSR\nGenerates the memory barrier instruction\nCalculate the approximate double-precision result of 1.0 …\nCalculate the approximate single-precision result of 1.0 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculate the approximate double-precision result of …\nCalculate the approximate single-precision result of …\nGenerates the instruction-fetch barrier instruction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads the 8-bit IO-CSR\nReads the 64-bit IO-CSR\nReads the 16-bit IO-CSR\nReads the 32-bit IO-CSR\nWrites the 8-bit IO-CSR\nWrites the 64-bit IO-CSR\nWrites the 16-bit IO-CSR\nWrites the 32-bit IO-CSR\nLoads the page table directory entry\nLoads the page table entry\nMoves data from a FCSR to the GPR\nMoves data from a GPR to the FCSR\nReads the 64-bit stable counter value and the counter ID\nReads the upper 32-bit stable counter value and the …\nReads the lower 32-bit stable counter value and the …\nGenerates the syscall instruction\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>i16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 16 packed <code>u16</code>.\nLOONGARCH-specific 128-bit wide vector of 16 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 2 packed <code>u64</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>i8</code>.\nLOONGARCH-specific 256-bit wide vector of 32 packed <code>u8</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>f32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>f64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>i32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>i64</code>.\nLOONGARCH-specific 128-bit wide vector of 4 packed <code>u32</code>.\nLOONGARCH-specific 256-bit wide vector of 4 packed <code>u64</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>f32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>i16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>i32</code>.\nLOONGARCH-specific 128-bit wide vector of 8 packed <code>u16</code>.\nLOONGARCH-specific 256-bit wide vector of 8 packed <code>u32</code>.\nGenerates the trap instruction <code>BREAK</code>\nGenerates the trap instruction <code>BREAK</code>\nSyscall to be used whenever the <em>assert expression produces </em>…\nx-th thread-block dimension.\ny-th thread-block dimension.\nz-th thread-block dimension.\nx-th thread-block index.\ny-th thread-block index.\nz-th thread-block index.\nx-th block-grid dimension.\ny-th block-grid dimension.\nz-th block-grid dimension.\nSynchronizes all threads in the block.\nx-th thread index.\ny-th thread index.\nz-th thread index.\nPTX-specific 32-bit wide floating point (f16 x 2) vector …\nAdd two values, round to nearest even\nFused multiply-add, round to nearest even\nFind the maximum of two values\nFind the maximum of two values, NaNs pass through.\nFind the minimum of two values\nFind the minimum of two values, NaNs pass through.\nMultiply two values, round to nearest even\nArithmetic negate\nSubtract two values, round to nearest even\nFree previously dynamically allocated memory.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllocate memory dynamically from a fixed-size heap in …\nGenerates the trap instruction <code>TRAP</code>\nPrint formatted output from a kernel to a host-side output …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Unsigned Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector xor.\nVSX Unaligned Store\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the trap instruction <code>TRAP</code>\nVector abs.\nVector abss.\nVector add.\nVector addc.\nVector Add Extended\nVector adds.\nVector All Elements Equal\nVector All Elements Greater or Equal\nVector All Elements Greater Than\nVector All In\nVector All Elements Less Than or Equal\nVector All Elements Less Than\nAll Elements Not a Number\nVector All Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector and.\nVector andc.\nVector All Elements Equal\nVector Any Element Greater or Equal\nVector Any Element Greater Than\nVector Any Element Less Than or Equal\nVector Any Element Less Than\nAny Elements Not a Number\nVector Any Elements Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nAny Element Out of Bounds\nVector avg.\nVector ceil.\nVector cmpb.\nVector cmpeq.\nVector cmpge.\nVector cmpgt.\nVector cmple.\nVector cmplt.\nVector Compare Not Equal\nVector Count Leading Zeros\nVector Convert to Floating-Point\nVector Convert to Signed Integer\nVector Convert to Unsigned Integer\nVector expte.\nVector Extract\nVector floor.\nVector Insert\nVector Load Indexed.\nVector Load Element Indexed.\nVector Load Indexed Least Recently Used.\nVector Base-2 Logarithm Estimate\nVector Multiply Add\nVector Multiply Add Saturated\nVector max.\nVector Merge Even\nVector Merge High\nVector Merge Low\nVector Merge Odd\nMove From Vector Status and Control Register.\nVector min.\nVector Multiply Low and Add Unsigned Half Word\nVector Multiply Round and Add Saturated\nVector Multiply Sum\nVector Multiply Sum Saturated\nVector Multiply\nVector Multiply Even\nVector Multiply Odd\nVector NAND\nVector Negative Multiply Subtract\nVector nor.\nVector or.\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Unsigned\nVector permute.\nVector Rotate Left\nVector Round\nVector Select\nVector Shift Left\nVector Shift Left Double\nVector Shift Left Double by Words\nVector Shift Left Long\nVector Shift Left by Octets\nVector Shift Left Variable\nVector Splat\nVector Splat to Signed Halfword\nVector Splat to Signed Word\nVector Splat to Signed Byte\nVector Splat to Unsigned Halfword\nVector Splat to Unsigned Word\nVector Splat to Unsigned Byte\nVector splats.\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Long\nVector Shift Right by Octets\nVector Shift Right Variable\nVector Store Indexed\nVector Store Element Indexed\nVector Store Indexed Least Recently Used\nVector sub.\nVector Subtract Carryout\nVector subs.\nVector Sum Across Partial (1/2) Saturated\nVector Sum Across Partial (1/4) Saturated\nVector Unpack High\nVector Unpack Low\nVSX Unaligned Load\nVector Load with Length\nVector xor.\nVSX Unaligned Store\nVector Store with Length\nVector permute.\nPowerPC-specific 128-bit wide vector mask of sixteen …\nPowerPC-specific 128-bit wide vector mask of four packed …\nPowerPC-specific 128-bit wide vector mask of two <code>i64</code>\nPowerPC-specific 128-bit wide vector mask of eight packed …\nPowerPC-specific 128-bit wide vector of two packed <code>f64</code>\nPowerPC-specific 128-bit wide vector of four packed <code>f32</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>i8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>i32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>i64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>i16</code>\nPowerPC-specific 128-bit wide vector of sixteen packed <code>u8</code>\nPowerPC-specific 128-bit wide vector of four packed <code>u32</code>\nPowerPC-specific 128-bit wide vector of two packed <code>u64</code>\nPowerPC-specific 128-bit wide vector of eight packed <code>u16</code>\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV32.\nAES middle round decryption instruction for RV32.\nAES final round encryption instruction for RV32.\nAES middle round encryption instruction for RV32 with.\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the high half of the Sigma0 transformation, as …\nImplements the low half of the Sigma0 transformation, as …\nImplements the high half of the Sigma1 transformation, as …\nImplements the low half of the Sigma1 transformation, as …\nImplements the Sum0 transformation, as used in the …\nImplements the Sum1 transformation, as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nPlace odd and even bits of the source word into …\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nPlace upper/lower halves of the source register into …\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nAdds packed 16-bit signed numbers, discarding overflow bits\nAdds packed 8-bit signed numbers, discarding overflow bits\nAES final round decryption instruction for RV64.\nAES middle round decryption instruction for RV64.\nAES final round encryption instruction for RV64.\nAES middle round encryption instruction for RV64.\nThis instruction accelerates the inverse MixColumns step …\nThis instruction implements part of the KeySchedule …\nThis instruction implements part of the KeySchedule …\nCarry-less multiply (low-part)\nCarry-less multiply (high-part)\nCarry-less multiply (reversed)\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of redundant sign bits of the packed …\nCount the number of leading zero bits of the packed 16-bit …\nCount the number of leading zero bits of the packed 32-bit …\nCount the number of leading zero bits of the packed 8-bit …\nCompare equality for packed 16-bit elements\nCompare equality for packed 8-bit elements\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nGenerates the <code>FENCE.I</code> instruction\nReads the floating-point rounding mode register <code>frm</code>\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for all virtual …\nHypervisor memory management fence for guest physical …\nHypervisor memory management fence for given virtual …\nHypervisor memory management fence for given guest virtual …\nHypervisor memory management fence for all guest address …\nHypervisor memory management fence for given guest address …\nHypervisor memory management fence for given guest virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for all virtual …\nInvalidate hypervisor translation cache for guest physical …\nInvalidate hypervisor translation cache for given virtual …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for all guest …\nInvalidate hypervisor translation cache for given guest …\nInvalidate hypervisor translation cache for given guest …\nLoads virtual machine memory by signed byte integer\nLoads virtual machine memory by unsigned byte integer\nLoads virtual machine memory by double integer\nLoads virtual machine memory by signed half integer\nLoads virtual machine memory by unsigned half integer\nLoads virtual machine memory by signed word integer\nLoads virtual machine memory by unsigned word integer\nAccesses virtual machine instruction by unsigned half …\nAccesses virtual machine instruction by unsigned word …\nStores virtual machine memory by byte integer\nStores virtual machine memory by double integer\nStores virtual machine memory by half integer\nStores virtual machine memory by word integer\nCompute the absolute value of packed 16-bit signed integers\nCompute the absolute value of packed 8-bit signed integers\nAdds packed 16-bit signed numbers, saturating at the …\nAdds packed 8-bit signed numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with Q15 …\nCross adds and subtracts packed 16-bit signed numbers, …\nCross subtracts and adds packed 16-bit signed numbers, …\nLogical left shift packed 16-bit elements, saturating at …\nLogical left shift packed 8-bit elements, saturating at …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nLogical saturating left then arithmetic right shift packed …\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, saturating at the …\nSubtracts packed 8-bit signed numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nGenerates the <code>NOP</code> instruction\nBitwise OR-Combine, byte granule\nGenerates the <code>PAUSE</code> instruction\nCalculate the sum of absolute difference of unsigned 8-bit …\nCalculate and accumulate the sum of absolute difference of …\nPack two 16-bit data from bottom and top half from 32-bit …\nPack two 16-bit data from top and bottom half from 32-bit …\nHalves the sum of packed 16-bit signed numbers, dropping …\nHalves the sum of packed 8-bit signed numbers, dropping …\nCross halves of adds and subtracts packed 16-bit signed …\nCross halves of subtracts and adds packed 16-bit signed …\nStraight halves of adds and subtracts packed 16-bit signed …\nStraight halves of subtracts and adds packed 16-bit signed …\nHalves the subtraction result of packed 16-bit signed …\nHalves the subtraction result of packed 8-bit signed …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nCompare whether 16-bit packed signed integers are less …\nCompare whether 8-bit packed signed integers are less than …\nGenerates the <code>SFENCE.INVAL.IR</code> instruction\nSupervisor memory management fence for given virtual …\nSupervisor memory management fence for all address spaces …\nSupervisor memory management fence for given address space\nSupervisor memory management fence for given virtual …\nGenerates the <code>SFENCE.W.INVAL</code> instruction\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nImplements the Sigma0 transformation function as used in …\nImplements the Sigma1 transformation function as used in …\nImplements the Sum0 transformation function as used in the …\nImplements the Sum1 transformation function as used in the …\nInvalidate supervisor translation cache for given virtual …\nInvalidate supervisor translation cache for all address …\nInvalidate supervisor translation cache for given address …\nInvalidate supervisor translation cache for given virtual …\nLogical left shift packed 16-bit elements, discarding …\nLogical left shift packed 8-bit elements, discarding …\nImplements the P0 transformation function as used in the …\nImplements the P1 transformation function as used in the …\nAccelerates the block encrypt/decrypt operation of the SM4 …\nAccelerates the Key Schedule operation of the SM4 block …\nMultiply signed 8-bit elements and add 16-bit elements on …\nMultiply signed to unsigned 8-bit and add 16-bit elements …\nGet maximum values from 16-bit packed signed integers\nGet maximum values from 8-bit packed signed integers\nGet minimum values from 16-bit packed signed integers\nGet minimum values from 8-bit packed signed integers\nArithmetic right shift packed 16-bit elements without …\nArithmetic right shift packed 16-bit elements with …\nArithmetic right shift packed 8-bit elements without …\nArithmetic right shift packed 8-bit elements with rounding …\nLogical right shift packed 16-bit elements without …\nLogical right shift packed 16-bit elements with rounding up\nLogical right shift packed 8-bit elements without rounding …\nLogical right shift packed 8-bit elements with rounding up\nStraight adds and subtracts packed 16-bit signed numbers, …\nStraight subtracts and adds packed 16-bit signed numbers, …\nSubtracts packed 16-bit signed numbers, discarding …\nSubtracts packed 8-bit signed numbers, discarding overflow …\nUnpack first and zeroth into two 16-bit signed halfwords …\nUnpack second and zeroth into two 16-bit signed halfwords …\nUnpack third and zeroth into two 16-bit signed halfwords …\nUnpack third and first into two 16-bit signed halfwords in …\nUnpack third and second into two 16-bit signed halfwords …\nSwap the 16-bit halfwords within each 32-bit word of a …\nSwap the 8-bit bytes within each 16-bit halfword of a …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nCompare whether 16-bit packed unsigned integers are less …\nCompare whether 8-bit packed unsigned integers are less …\nAdds packed 16-bit unsigned numbers, saturating at the …\nAdds packed 8-bit unsigned numbers, saturating at the …\nAdds signed lower 16-bit content of two registers with U16 …\nCross adds and subtracts packed 16-bit unsigned numbers, …\nCross subtracts and adds packed 16-bit unsigned numbers, …\nStraight adds and subtracts packed 16-bit unsigned …\nStraight subtracts and adds packed 16-bit unsigned …\nSubtracts packed 16-bit unsigned numbers, saturating at …\nSubtracts packed 8-bit unsigned numbers, saturating at the …\nSubtracts signed lower 16-bit content of two registers …\nMultiply unsigned 8-bit elements and add 16-bit elements …\nGet maximum values from 16-bit packed unsigned integers\nGet maximum values from 8-bit packed unsigned integers\nGet minimum values from 16-bit packed unsigned integers\nGet minimum values from 8-bit packed unsigned integers\nHalves the sum of packed 16-bit unsigned numbers, dropping …\nHalves the sum of packed 8-bit unsigned numbers, dropping …\nCross halves of adds and subtracts packed 16-bit unsigned …\nCross halves of subtracts and adds packed 16-bit unsigned …\nStraight halves of adds and subtracts packed 16-bit …\nStraight halves of subtracts and adds packed 16-bit …\nHalves the subtraction result of packed 16-bit unsigned …\nHalves the subtraction result of packed 8-bit unsigned …\nGenerates the <code>WFI</code> instruction\nNibble-wise lookup of indicies into a vector.\nByte-wise lookup of indicies into a vector in registers.\nUnpack first and zeroth into two 16-bit unsigned halfwords …\nUnpack second and zeroth into two 16-bit unsigned …\nUnpack third and zeroth into two 16-bit unsigned halfwords …\nUnpack third and first into two 16-bit unsigned halfwords …\nUnpack third and second into two 16-bit unsigned halfwords …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVector Absolute\nVector Add\nVector Addition unsigned 128-bits\nVector Add Compute Carryout unsigned 128-bits\nVector Add With Carry unsigned 128-bits\nVector Add With Carry Compute Carry unsigned 128-bits\nAll Elements Equal\nAll Elements Greater Than or Equal\nAll Elements Greater Than\nAll Elements Less Than or Equal\nAll Elements Less Than\nAll Elements Not a Number\nAll Elements Not Equal\nAll Elements Not Greater Than or Equal\nAll Elements Not Greater Than\nAll Elements Not Less Than or Equal\nAll Elements Not Less Than\nAll Elements Numeric\nVector AND\nVector ANDC\nAny Element Equal\nAny Elements Greater Than or Equal\nAny Elements Greater Than\nAny Elements Less Than or Equal\nAny Elements Less Than\nAny Elements Not a Number\nAny Element Not Equal\nAny Elements Not Greater Than or Equal\nAny Elements Not Greater Than\nAny Elements Not Less Than or Equal\nAny Elements Not Less Than\nAny Elements Numeric\nVector Average\nVector Bit Permute\nVector Ceil\nVector Checksum\nVector Compare Equal\nVector Compare Equal Index\nVector Compare Equal Index with Condition Code\nVector Compare Equal or Zero Index\nVector Compare Equal or Zero Index with Condition Code\nVector Compare Greater Than or Equal\nVector Compare Greater Than\nVector Compare Less Than or Equal\nVector Compare Less\nVector Compare Not Equal\nVector Compare Not Equal Index\nVector Compare Not Equal Index with Condition Code\nVector Compare Not Equal or Zero Index\nVector Compare Not Equal or Zero Index with Condition Code\nVector Compare Not in Ranges\nVector Compare Not in Ranges with Condition Code\nVector Compare Not in Ranges Index\nVector Compare Not in Ranges Index with Condition Code\nVector Compare Not in Ranges or Zero Index\nVector Compare Not in Ranges or Zero Index with Condition …\nVector Compare Ranges\nVector Compare Ranges with Condition Code\nVector Compare Ranges Index\nVector Compare Ranges Index with Condition Code\nVector Compare Ranges or Zero Index\nVector Compare Ranges or Zero Index with Condition Code\nVector Count Leading Zeros\nVector Count Trailing Zeros\nVector Copy Until Zero\nVector Copy Until Zero\nVector Convert from long long to double\nVector Convert from float (even elements) to double\nVector XNOR\nVector Sign Extend to Doubleword\nVector Extract\nVector Find Any Element Equal with Condition Code\nVector Find Any Element Equal with Condition Code\nVector Find Any Element Equal Index with Condition Code\nVector Find Any Element Equal Index with Condition Code\nVector Find Any Element Equal or Zero Index with Condition …\nVector Find Any Element Equal or Zero Index with Condition …\nVector Find Any Element Not Equal with Condition Code\nVector Find Any Element Not Equal with Condition Code\nVector Find Any Element Not Equal Index with Condition Code\nVector Find Any Element Not Equal Index with Condition Code\nVector Find Any Element Not Equal or Zero Index with …\nVector Find Any Element Not Equal or Zero Index with …\nVector Convert from int to float\nVector Convert from double to float (even elements)\nVector Floor\nVector Floating-Point Test Data Class\nVector Gather Element\nVector Generate Byte Mask\nVector Generate Mask (Halfword)\nVector Generate Mask (Word)\nVector Generate Mask (Doubleword)\nVector Generate Mask (Byte)\nVector Galois Field Multiply Sum\nVector Galois Field Multiply Sum 128-bits\nVector Galois Field Multiply Sum\nVector Galois Field Multiply Sum and Accumulate 128-bits\nVector Insert\nVector Insert and Zero\nVector Load to Block Boundary\nVector Load with Length\nVector Load Rightmost with Length\nVector Load Pair\nVector Multiply Add\nVector Maximum\nVector Multiply and Add Even\nVector Merge High\nVector Merge Low\nVector Multiply and Add High\nVector  Minimum\nVector Multiply and Add Low\nVector Multiply and Add Odd\nVector Multiply Add\nVector Multiply Sum Logical\nVector Multiply\nVector Multiply Even\nVector Multiply High\nVector Multiply Odd\nVector Negative Absolute\nVector NAND\nVector Negative Multiply Add\nVector Negative Multiply Subtract\nVector NOR\nVector OR\nVector OR with Complement\nVector Pack\nVector Pack Saturated\nVector Pack Saturated Condition Code\nVector Pack Saturated Unsigned\nVector Pack Saturated Unsigned Condition Code\nVector Permute\nVector Population Count\nVector Promote\nVector Byte Reverse\nVector Reverse Elements\nVector Round to Integer\nVector Element Rotate Left\nVector Element Rotate Left Immediate\nVector Round\nVector Round to Current\nVector Round toward Negative Infinity\nVector Round toward Positive Infinity\nVector Round toward Zero\nVector Search String\nVector Search String Until Zero\nVector Select\nVector Convert floating point to signed\nVector Shift Left\nVector Shift Left by Byte\nVector Shift Left Double by Byte\nVector Shift Left Double by Bit\nVector Shift Left Double by Word\nVector Shift Left\nVector Splat\nVector Splat Signed Halfword\nVector Splat Signed Word\nVector Splat Signed Doubleword\nVector Splat Signed Byte\nVector Splat Unsigned Halfword\nVector Splat Unsigned Word\nVector Splat Unsigned Doubleword\nVector Splat Unsigned Byte\nVector Splats\nVector Square Root\nVector Shift Right\nVector Shift Right Algebraic\nVector Shift Right Algebraic by Byte\nVector Shift Right Arithmetic\nVector Shift Right by Byte\nVector Shift Right Double by Bit\nVector Shift Right\nVector Store with Length\nVector Store Rightmost with Length\nVector Subtract\nVector Subtract unsigned 128-bits\nVector Subtract Carryout\nVector Subtract Carryout unsigned 128-bits\nVector Subtract with Carryout\nVector Subtract with Carryout, Carryout\nVector Sum Across Doubleword\nVector Sum Across Word\nVector Sum Across Quadword\nVector Test under Mask\nVector Truncate\nVector Unpack High\nVector Unpack Low\nVector Convert floating point to unsigned\nVector Load\nVector XOR\nVector Store\ns390x-specific 128-bit wide vector mask of sixteen packed …\ns390x-specific 128-bit wide vector mask of four packed …\ns390x-specific 128-bit wide vector mask of two packed …\ns390x-specific 128-bit wide vector mask of eight packed …\ns390x-specific 128-bit wide vector of two packed <code>f64</code>\ns390x-specific 128-bit wide vector of four packed <code>f32</code>\ns390x-specific 128-bit wide vector of sixteen packed <code>i8</code>\ns390x-specific 128-bit wide vector of four packed <code>i32</code>\ns390x-specific 128-bit wide vector of two packed <code>i64</code>\ns390x-specific 128-bit wide vector of eight packed <code>i16</code>\ns390x-specific 128-bit wide vector of sixteen packed <code>u8</code>\ns390x-specific 128-bit wide vector of four packed <code>u32</code>\ns390x-specific 128-bit wide vector of two packed <code>u64</code>\ns390x-specific 128-bit wide vector of eight packed <code>u16</code>\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nReturns the argument unchanged.\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCalls <code>U::from(self)</code>.\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>u32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>u32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLoad two 32-bit integers and zero extend each one to a …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise unsigned integers, and returns the …\nCompares lane-wise unsigned integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nGenerates the <code>unreachable</code> instruction, which causes an …\nWASM-specific 128-bit wide SIMD vector type.\nPerforms a bitwise and of the two input 128-bit vectors, …\nBitwise AND of bits of <code>a</code> and the logical inverse of bits …\nReturns <code>true</code> if any bit in <code>a</code> is set, or <code>false</code> otherwise.\nUse the bitmask in <code>c</code> to select bits from <code>v1</code> when 1 and <code>v2</code> …\nLoads a <code>v128</code> vector from the given heap address.\nLoads a 16-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoads a 32-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 32-bit element into the low bits of the vector and …\nLoads a 64-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nLoad a 64-bit element into the low bits of the vector and …\nLoads an 8-bit value from <code>m</code> and sets lane <code>L</code> of <code>v</code> to that …\nLoad a single element and splat to all lanes of a v128 …\nFlips each bit of the 128-bit input vector.\nPerforms a bitwise or of the two input 128-bit vectors, …\nStores a <code>v128</code> vector to the given heap address.\nStores the 16-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 32-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 64-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nStores the 8-bit value from lane <code>L</code> of <code>v</code> into <code>m</code>\nPerforms a bitwise xor of the two input 128-bit vectors, …\nGenerates the <code>f32.ceil</code> instruction, returning the smallest …\nGenerates the <code>f32.floor</code> instruction, returning the largest …\nGenerates the <code>f32.nearest</code> instruction, roundinging to the …\nGenerates the <code>f32.sqrt</code> instruction, returning the square …\nGenerates the <code>f32.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise addition of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value not …\nConverts a 128-bit vector interpreted as four 32-bit …\nConverts a 128-bit vector interpreted as four 32-bit …\nConversion of the two double-precision floating point …\nLane-wise division of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiplication of two 128-bit vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as four …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f32x4_max</code> which is either <code>f32x4_max</code> or\nA relaxed version of <code>f32x4_min</code> which is either <code>f32x4_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtraction of two 128-bit vectors interpreted …\nLane-wise rounding to the nearest integral value with the …\nGenerates the <code>f64.ceil</code> instruction, returning the smallest …\nGenerates the <code>f64.floor</code> instruction, returning the largest …\nGenerates the <code>f64.nearest</code> instruction, roundinging to the …\nGenerates the <code>f64.sqrt</code> instruction, returning the square …\nGenerates the <code>f64.trunc</code> instruction, roundinging to the …\nMaterializes a SIMD value from the provided operands.\nCalculates the absolute value of each lane of a 128-bit …\nLane-wise add of two 128-bit vectors interpreted as two …\nLane-wise rounding to the nearest integral value not …\nLane-wise conversion from integer to floating point.\nLane-wise conversion from integer to floating point.\nLane-wise divide of two 128-bit vectors interpreted as two …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nLane-wise rounding to the nearest integral value not …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCalculates the lane-wise maximum of two 128-bit vectors …\nCalculates the lane-wise minimum of two 128-bit vectors …\nLane-wise multiply of two 128-bit vectors interpreted as …\nCompares two 128-bit vectors as if they were two vectors …\nLane-wise rounding to the nearest integral value; if two …\nNegates each lane of a 128-bit vector interpreted as two …\nLane-wise maximum value, defined as <code>a &lt; b ? b : a</code>\nLane-wise minimum value, defined as <code>b &lt; a ? b : a</code>\nConversion of the two lower single-precision floating …\nComputes <code>a * b + c</code> with either one rounding or two …\nA relaxed version of <code>f64x2_max</code> which is either <code>f64x2_max</code> or\nA relaxed version of <code>f64x2_min</code> which is either <code>f64x2_min</code> or\nComputes <code>-a * b + c</code> with either one rounding or two …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nCreates a vector with identical lanes.\nCalculates the square root of each lane of a 128-bit …\nLane-wise subtract of two 128-bit vectors interpreted as …\nLane-wise rounding to the nearest integral value with the …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad eight 8-bit integers and sign extend each one to a …\nLoad eight 8-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as eight 16-bit …\nLane-wise saturating rounding multiplication in Q15 format.\nA relaxed dot-product instruction.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i16x8_relaxed_q15mulr</code> where if both …\nReplaces a lane from a 128-bit vector interpreted as 8 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed four …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nLane-wise multiply signed 16-bit integers in the two input …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 4 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad four 16-bit integers and sign extend each one to a …\nLoad four 16-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as four 32-bit …\nSimilar to <code>i16x8_relaxed_dot_i8x16_i7x16</code> except that the …\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i32x4_trunc_sat_f32x4(a)</code> converts the …\nA relaxed version of <code>i32x4_trunc_sat_f64x2_zero(a)</code> …\nReplaces a lane from a 128-bit vector interpreted as 4 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nConverts a 128-bit vector interpreted as four 32-bit …\nSaturating conversion of the two double-precision floating …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed two …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nConverts high half of the smaller lane vector to a larger …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 2 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nLoad two 32-bit integers and sign extend each one to a …\nLoad two 32-bit integers and zero extend each one to a …\nCompares two 128-bit vectors as if they were two vectors …\nMultiplies two 128-bit vectors as if they were two packed …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as two 64-bit signed …\nA relaxed version of <code>v128_bitselect</code> where this either …\nReplaces a lane from a 128-bit vector interpreted as 2 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nSame as <code>i8x16_shuffle</code>, except operates as if the inputs …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nMaterializes a SIMD value from the provided operands.\nLane-wise wrapping absolute value.\nAdds two 128-bit vectors as if they were two packed …\nAdds two 128-bit vectors as if they were two packed …\nReturns true if all lanes are non-zero, false otherwise.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nExtracts a lane from a 128-bit vector interpreted as 16 …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares two 128-bit vectors as if they were two vectors …\nCompares lane-wise signed integers, and returns the …\nCompares lane-wise signed integers, and returns the …\nConverts two input vectors into a smaller lane vector by …\nCompares two 128-bit vectors as if they were two vectors …\nNegates a 128-bit vectors interpreted as sixteen 8-bit …\nCount the number of bits set to one within each lane.\nA relaxed version of <code>v128_bitselect</code> where this either …\nA relaxed version of <code>i8x16_swizzle(a, s)</code> which selects …\nReplaces a lane from a 128-bit vector interpreted as 16 …\nShifts each lane to the left by the specified number of …\nShifts each lane to the right by the specified number of …\nReturns a new vector with lanes selected from the lanes of …\nCreates a vector with identical lanes.\nSubtracts two 128-bit vectors as if they were two packed …\nSubtracts two 128-bit vectors as if they were two packed …\nReturns a new vector with lanes selected from the lanes of …\nCorresponding intrinsic to wasm’s <code>memory.atomic.notify</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait32</code> …\nCorresponding intrinsic to wasm’s <code>memory.atomic.wait64</code> …\nCorresponding intrinsic to wasm’s <code>memory.grow</code> instruction\nCorresponding intrinsic to wasm’s <code>memory.size</code> instruction\nGenerates the <code>throw</code> instruction from the …\nMaterializes a SIMD value from the provided operands.\nAdds two 128-bit vectors as if they were two packed eight …\nAdds two 128-bit vectors as if they were two packed eight …\nReturns true if all lanes are non-zero, false otherwise.\nLane-wise rounding average.\nExtracts the high bit for each lane in <code>a</code> and produce a …\nCompares two 128-bit vectors as if they were two vectors …\nInteger extended pairwise addition producing extended …\nConverts high half of the smaller lane vector to a larger …\nConverts low half of the smaller lane vector to a larger …\nLane-wise integer extended multiplication producing twice …\nLane-wise integer extended multiplication producing twice …\nExtracts a lane from a 128-bit vector interpreted as 8 …")